1.#include <stdio.h>
2.#include <stdlib.h>
3.#include <string.h>
4.#include <errno.h>
5.#include <sys/stat.h>
6.#include <sys/types.h>
7.#include <fcntl.h>
8.
9.#define MAX 100
10.
11.int child_work(int pfd,char *fname)
12.{
13.    int n,fd;
14.    char buf[MAX];
15.
16.    if((fd = open(fname,O_WRONLY | O_CREAT | O_TRUNC,0666)) < 0)
17.    {
18.        fprintf(stderr,"Fail to open %s : %s.\n",fname,strerror(errno));
19.        return -1;
20.    }
21.
22.    while( n = read(pfd,buf,sizeof(buf)) )
23.    {
24.        write(fd,buf,n);
25.    }
26.    
27.    close(pfd);
28.
29.    return 0;
30.}
31.
32.int father_work(int pfd,char *fname)
33.{
34.    int fd,n;
35.    char buf[MAX];
36.
37.    if((fd = open(fname,O_RDONLY)) < 0)
38.    {
39.        fprintf(stderr,"Fail to open %s : %s.\n",fname,strerror(errno));
40.        return -1;
41.    }
42.
43.    while(n = read(fd,buf,sizeof(buf)))
44.    {
45.        write(pfd,buf,n);
46.    }
47.    
48.    close(pfd);
49.
50.    return 0;
51.}
52.
53.int main(int argc,char *argv[])
54.{
55.    int pid;
56.    int fd[2];
57.
58.    if(argc < 3)
59.    {
60.        fprintf(stderr,"usage %s argv[1] argv[2].\n",argv[0]);
61.        exit(EXIT_FAILURE);
62.    }
63.
64.    if(pipe(fd) < 0)
65.    {
66.        perror("Fail to pipe");
67.        exit(EXIT_FAILURE);
68.    }
69.
70.    if((pid = fork()) < 0)
71.    {
72.        perror("Fail to fork");
73.        exit(EXIT_FAILURE);
74.    
75.    }else if(pid == 0){
76.        
77.        close(fd[1]);
78.        child_work(fd[0],argv[2]);
79.    
80.    }else{
81.    
82.        close(fd[0]);
83.        father_work(fd[1],argv[1]);
84.        wait(NULL);
85.    }
86.
87.    exit(EXIT_SUCCESS);
88.}